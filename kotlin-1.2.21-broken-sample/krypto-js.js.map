{"version":3,"file":"krypto-js.js","sources":["../../../../../common/src/main/kotlin/com/soywiz/krypto/AES.kt","../../../../../common/src/main/kotlin/com/soywiz/krypto/Krypto.kt","../../../../../common/src/main/kotlin/com/soywiz/krypto/SHA1.kt","../../../../src/main/kotlin/com/soywiz/kmem/KmemGenJs.kt","../../../../../common/src/main/kotlin/com/soywiz/kmem/KmemGen.kt","core/math.kt","../../../../../common/src/main/kotlin/com/soywiz/kmem/UByteArray.kt","util/Standard.kt","../../../../../common/src/main/kotlin/com/soywiz/krypto/KryptoVersion.kt"],"sourcesContent":[null,null,null,null,null,"/*\n * Copyright 2010-2017 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n@file:Suppress(\"DEPRECATION\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n// constants, can't use them from nativeMath as they are not constants there\n\n/** Ratio of the circumference of a circle to its diameter, approximately 3.14159. */\n@SinceKotlin(\"1.2\")\npublic const val PI: Double = 3.141592653589793\n/** Base of the natural logarithms, approximately 2.71828. */\n@SinceKotlin(\"1.2\")\npublic const val E: Double = 2.718281828459045\n\n// ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\npublic fun Double.withSign(sign: Double): Double {\n    val thisSignBit = js(\"Kotlin\").doubleSignBit(this).unsafeCast<Int>()\n    val newSignBit = js(\"Kotlin\").doubleSignBit(sign).unsafeCast<Int>()\n    return if (thisSignBit == newSignBit) this else -this\n}\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */-> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n\n\n\n// ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun min(a: Int, b: Int): Int = minOf(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun max(a: Int, b: Int): Int = maxOf(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun min(a: Long, b: Long): Long = minOf(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline fun max(a: Long, b: Long): Long = maxOf(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n",null,"@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.internal.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0..times - 1) {\n        action(index)\n    }\n}\n",null],"names":[],"mappings":"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"}